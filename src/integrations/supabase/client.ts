// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { Json } from './types';

const SUPABASE_URL = "https://tudbtihblxsgxveanbtv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1ZGJ0aWhibHhzZ3h2ZWFuYnR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3NDU1ODksImV4cCI6MjA1NzMyMTU4OX0.hRUW1xJskHPbjXQz4VezaRJ0yhcTt76bvYejL1ZvKaw";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Define types for the tables we've created
export type Dish = {
  id: string;
  name: string;
  createdAt: string;
  cuisines: string[];
  source?: {
    type: 'url' | 'book' | 'none';
    value: string;
    page?: number;
    bookId?: string;
  };
  lastMade?: string;
  timesCooked: number;
  user_id: string;
};

export type MealHistory = {
  id: string;
  dishId: string;
  date: string;
  notes?: string;
  user_id: string;
};

export type Cookbook = {
  id: string;
  name: string;
  author?: string;
  description?: string;
  createdAt: string;
  user_id: string;
};

// Type for our materialized view
export type DishSummary = {
  id: string;
  name: string;
  createdat: string;
  cuisines: string[];
  source?: any;
  user_id: string;
  times_cooked: number;
  last_made?: string;
};

// Mapping functions to convert between database and client formats
export const mapDishFromDB = (dish: Database['public']['Tables']['dishes']['Row'], mealHistory?: any[]): Dish => {
  // Default values for derived fields
  let timesCooked = 0;
  let lastMade: string | undefined = undefined;
  
  // If meal history is provided, use it to calculate timesCooked and lastMade
  if (mealHistory && mealHistory.length > 0) {
    timesCooked = mealHistory.length;
    
    // Find the most recent meal date
    const sortedDates = [...mealHistory].sort((a, b) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    
    if (sortedDates.length > 0) {
      lastMade = sortedDates[0].date;
    }
  }
  
  return {
    id: dish.id,
    name: dish.name,
    createdAt: dish.createdat,
    cuisines: dish.cuisines,
    source: dish.source as any,
    lastMade,  // Derived value
    timesCooked, // Derived value
    user_id: dish.user_id
  };
};

// Updated function to map from our materialized view
export const mapDishFromSummary = (summary: DishSummary): Dish => {
  // Ensure source property is properly formatted
  let formattedSource = undefined;
  
  if (summary.source) {
    // If source exists, ensure it matches the expected format
    const source = summary.source as any;
    
    // Make sure source has the expected structure
    if (typeof source === 'object' && (
        source.type === 'url' || 
        source.type === 'book' || 
        source.type === 'none'
      )) {
      formattedSource = {
        type: source.type,
        value: source.value || '',
        ...(source.page !== undefined ? { page: source.page } : {}),
        ...(source.bookId !== undefined ? { bookId: source.bookId } : {})
      };
    }
  }
  
  return {
    id: summary.id,
    name: summary.name,
    createdAt: summary.createdat,
    cuisines: summary.cuisines,
    source: formattedSource,
    lastMade: summary.last_made,
    timesCooked: summary.times_cooked || 0,
    user_id: summary.user_id
  };
};

export const mapDishToDB = (dish: Partial<Dish>): Partial<Database['public']['Tables']['dishes']['Insert']> => {
  // Ensure required fields are present when inserting a new dish
  if (dish.name === undefined && !dish.id) {
    throw new Error('Name is required when creating a new dish');
  }
  
  return {
    id: dish.id,
    name: dish.name,
    createdat: dish.createdAt,
    cuisines: dish.cuisines,
    source: dish.source as any,
    user_id: dish.user_id
  };
};

export const mapMealHistoryFromDB = (history: Database['public']['Tables']['meal_history']['Row']): MealHistory => ({
  id: history.id,
  dishId: history.dishid,
  date: history.date,
  notes: history.notes || undefined,
  user_id: history.user_id
});

export const mapMealHistoryToDB = (history: Partial<MealHistory>): Partial<Database['public']['Tables']['meal_history']['Insert']> => {
  // Ensure required fields are present when inserting a new meal history record
  if (history.dishId === undefined && !history.id) {
    throw new Error('DishId is required when creating a new meal history record');
  }
  
  return {
    id: history.id,
    dishid: history.dishId,
    date: history.date,
    notes: history.notes,
    user_id: history.user_id
  };
};

export const mapCookbookFromDB = (cookbook: Database['public']['Tables']['cookbooks']['Row']): Cookbook => ({
  id: cookbook.id,
  name: cookbook.name,
  author: cookbook.author || undefined,
  description: cookbook.description || undefined,
  createdAt: cookbook.createdat,
  user_id: cookbook.user_id
});

export const mapCookbookToDB = (cookbook: Partial<Cookbook>): Partial<Database['public']['Tables']['cookbooks']['Insert']> => {
  // Ensure required fields are present when inserting a new cookbook
  if (cookbook.name === undefined && !cookbook.id) {
    throw new Error('Name is required when creating a new cookbook');
  }
  
  return {
    id: cookbook.id,
    name: cookbook.name,
    author: cookbook.author,
    description: cookbook.description,
    createdat: cookbook.createdAt,
    user_id: cookbook.user_id
  };
};
